import { FC, useMemo, useState } from 'react';
import { useCockpitWorkspace } from '../hooks/useCockpitWorkspace';
import { type RecoveryRunbook, type StageNode } from '@domain/recovery-orchestration-design';
import { withBrand } from '@shared/core';
import { useRecoveryStudioOrchestrator } from '../hooks/useRecoveryStudioOrchestrator';
import { useRecoveryStudioDiagnostics } from '../hooks/useRecoveryStudioDiagnostics';
import { StudioTopologyCanvas } from '../components/studio/StudioTopologyCanvas';
import { StudioRunStatusPanel } from '../components/studio/StudioRunStatusPanel';
import { StudioPluginRail } from '../components/studio/StudioPluginRail';
import type { RecoveryPlan as RecoveryPlanModel } from '@domain/recovery-cockpit-models';

const DEFAULT_TENANT = 'tenant:studio';

const phaseFromIndex = (index: number): StageNode['phase'] =>
  (['discover', 'stabilize', 'mitigate', 'validate', 'document'][index % 5] as StageNode['phase']);
const severityFromIndex = (index: number): StageNode['severity'] =>
  (['low', 'medium', 'high', 'critical', 'low'][index % 5] as StageNode['severity']);

const toRunbook = (plan: RecoveryPlanModel): RecoveryRunbook => {
  const now = new Date().toISOString();
  const nodes = plan.actions.map<StageNode>((action, index) => ({
    id: String(action.id),
    title: action.command,
    phase: phaseFromIndex(index),
    severity: severityFromIndex(index),
    status: 'pending',
    metrics: {
      slo: 1 - index / Math.max(1, plan.actions.length),
      capacity: Math.max(0.1, 1 - index / 20),
      compliance: Math.max(0.25, 1 - index / 10),
      security: 0.8,
    },
    prerequisites: action.dependencies.map((dependency) => String(dependency)),
  }));

  return {
    tenant: withBrand('tenant:studio', 'TenantId'),
    workspace: withBrand('workspace:studio', 'WorkspaceId'),
    scenarioId: withBrand(String(plan.planId), 'ScenarioId'),
    title: `${plan.labels.short} orchestration`,
    nodes,
    edges: nodes
      .map((entry, index) => ({
        from: entry.id,
        to: nodes[index + 1]?.id ?? entry.id,
        latencyMs: 85,
      }))
      .filter((edge) => edge.from !== edge.to),
    directives: [
      {
        code: 'policy:studio',
        command: 'execute-plan',
        scope: plan.labels.short,
        requiredCapabilities: ['control', 'compute'],
        metadata: {
          planId: String(plan.planId),
        },
      },
    ],
    createdAt: now,
    updatedAt: now,
  };
};

export const RecoveryCockpitStudioOrchestrationsPage: FC = () => {
  const workspace = useCockpitWorkspace({ parallelism: 4, maxRuntimeMinutes: 45 });
  const runbooks = useMemo<readonly RecoveryRunbook[]>(() => workspace.plans.map((plan) => toRunbook(plan)), [workspace.plans]);

  const controller = useRecoveryStudioOrchestrator({
    tenant: DEFAULT_TENANT,
    workspace: 'workspace:studio',
    autoStartOnMount: true,
    runbooks,
    plans: workspace.plans,
  });

  const diagnostics = useRecoveryStudioDiagnostics({ runs: controller.runs });
  const [selectedPlugin, setSelectedPlugin] = useState('');

  return (
    <main style={{
      padding: 24,
      display: 'grid',
      gap: 16,
      fontFamily: 'Inter, system-ui, sans-serif',
      background: 'linear-gradient(180deg, #061226 0%, #05111f 100%)',
      color: '#e7ebff',
      minHeight: '100vh',
    }}>
      <header>
        <h1>Recovery Cockpit Studio Orchestrations</h1>
        <p>Execute and observe orchestration runs generated by the recovery design runtime.</p>
      </header>

      <section style={{ display: 'grid', gap: 12, gridTemplateColumns: 'repeat(auto-fit,minmax(240px,1fr))' }}>
        <div>
          <p><strong>Tenant</strong></p>
          <p>{DEFAULT_TENANT}</p>
        </div>
        <div>
          <p><strong>Workspace</strong></p>
          <p>workspace:studio</p>
        </div>
        <div>
          <p><strong>Total runs</strong></p>
          <p>{diagnostics.totalRuns}</p>
        </div>
        <div>
          <p><strong>Active plugin</strong></p>
          <p>{selectedPlugin || 'none'}</p>
        </div>
      </section>

      <section style={{ display: 'grid', gap: 12, gridTemplateColumns: '2fr 1fr' }}>
        <StudioTopologyCanvas
          runs={controller.runs}
          onSelect={(run) => {
            const target = runbooks[0];
            if (target) {
              void controller.refreshDiagnostics(target);
            }
          }}
        />
        <StudioPluginRail
          pluginIds={diagnostics.uniquePlugins}
          selectedPlugin={selectedPlugin}
          onChange={(value) => setSelectedPlugin(value)}
        />
      </section>

      <section>
        <h3>Controls</h3>
        <div style={{ display: 'flex', gap: 12 }}>
          {runbooks.map((runbook) => (
            <button
              type="button"
              key={runbook.scenarioId}
              onClick={() => controller.start(runbook)}
              disabled={controller.isRunning}
            >
              Run {runbook.title}
            </button>
          ))}
          <button type="button" onClick={controller.stop} disabled={!controller.isRunning}>Stop</button>
          <button type="button" onClick={() => controller.clear()}>Clear</button>
        </div>
      </section>

      <section style={{ display: 'grid', gap: 12, gridTemplateColumns: 'repeat(auto-fill,minmax(360px,1fr))' }}>
        {controller.runs.toReversed().map((run) => (
          <StudioRunStatusPanel key={run.sessionId} run={run} compact />
        ))}
      </section>

      <section>
        <h3>Trend</h3>
        <ol>
          {diagnostics.trend.map((entry) => (
            <li key={entry.label}>
              {entry.label}: {entry.value}
            </li>
          ))}
        </ol>
      </section>
    </main>
  );
};
